#pragma config(Sensor, S1,     M_CONTROL,      sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "C:\Users\gcronin\Documents\Robotics\RobotCDriver\rdpartyrobotcdr-3.0\rdpartyrobotcdr-3.0\drivers\common.h"

tByteArray I2Crequest;
tByteArray I2Cresponse;

bool I2CResetEncoders(tSensors nPortIndex, ubyte I2Caddress, int MotorNumber)
{
  I2Crequest[0] = 3;
  I2Crequest[1] = I2Caddress;
  I2Crequest[2] = (MotorNumber == 1) ? 0x44 : 0x47;
  I2Crequest[3] = 3;

  return writeI2C(nPortIndex, I2Crequest);
}

///MOVE TO ENCODER POSITION////////////////////////////
// Power should be set 0 to 100
// Position can be positive or negative
bool I2CMoveToPositionMotor(tSensors nPortIndex, ubyte I2Caddress, int MotorNumber, int power, long position)
{
  I2Crequest[0] = 8;
  I2Crequest[1] = I2Caddress;
  I2Crequest[2] = (MotorNumber == 1) ? 0x40 : 0x46;
  I2Crequest[3] = (MotorNumber == 1) ? (position>>24)&0xFF : power&0xFF;
  I2Crequest[4] = (MotorNumber == 1) ? (position>>16)&0xFF : 2;
  I2Crequest[5] = (MotorNumber == 1) ? (position>>8)&0xFF : (position>>24)&0xFF;
  I2Crequest[6] = (MotorNumber == 1) ? position&0xFF : (position>>16)&0xFF;
  I2Crequest[7] = (MotorNumber == 1) ? 2 : (position>>8)&0xFF;
  I2Crequest[8] = (MotorNumber == 1) ? power&0xFF : position&0xFF;

  return writeI2C(nPortIndex, I2Crequest);
}

///MOVE CONSTANT SPEED////////////////////////////
// Speed should be set -100 to 100
//
bool I2CMoveConstantSpeed(tSensors nPortIndex, ubyte I2Caddress, int MotorNumber, int speed)
{
	I2Crequest[0] = 4;
  I2Crequest[1] = I2Caddress;
  I2Crequest[2] = (MotorNumber == 1) ? 0x44 : 0x46;
  I2Crequest[3] = (MotorNumber == 1) ? 1 : speed&0xFF;
  I2Crequest[4] = (MotorNumber == 1) ? speed&0xFF : 1;

  return writeI2C(nPortIndex, I2Crequest);
  }


///////////READ ENCODER POSITION////////////////////
//
//  Returns a long variable (note NXT only displays int variables)
//  Returns -1 as error code for failed attempt
//
long I2CReadEncoders(tSensors nPortIndex, ubyte I2Caddress, int MotorNumber)
{
  I2Crequest[0] = 2;
  I2Crequest[1] = I2Caddress;
  I2Crequest[2] = (MotorNumber == 1) ? 0x4C : 0x50;

  if (!writeI2C(nPortIndex, I2Crequest, I2Cresponse, 4))
    return -1;

  return I2Cresponse[3] + (I2Cresponse[2]<<8) + (I2Cresponse[1]<<16) + (I2Cresponse[0]<<24);
}


///////////READ BUSY MODE BIT////////////////////
//
//  Returns 1 if moving to a position
//  Returns 0 if reached position
//  Returns -1 as error code for failed attempt
//
int I2CReadBusyBit(tSensors nPortIndex, ubyte I2Caddress, int MotorNumber)
{
	I2Crequest[0] = 2;
  I2Crequest[1] = I2Caddress;
  I2Crequest[2] = (MotorNumber == 1) ? 0x44 : 0x47;

  if (!writeI2C(nPortIndex, I2Crequest, I2Cresponse, 1))
    return -1;

  return (I2Cresponse[0]>>7)&0x01;
}


task main()
{
	long currentPosition = 0;

  while(true)
  {
    currentPosition = I2CReadEncoders(M_CONTROL, 0x02, 2);
    nxtDisplayString(5, " %i ", currentPosition);
    nxtDisplayString(6, " %i ", I2CReadBusyBit(M_CONTROL, 0x02, 2));
		I2CMoveToPositionMotor(M_CONTROL, 0x02, 2, 30, -10000);
		wait1Msec(50);
  }
}
